from typing import Tuple
from numpy import ndarray
import numpy as np


def rotmat2d(theta: float = 0, cos: float = None, sin: float = None):
    ct = cos or np.cos(theta)
    st = sin or np.sin(theta)
    R = np.array(
        [[ct, -st],
         [st, ct]]
    )
    return R


def f_m2_withT(
        x: np.ndarray,
        T: float,
) -> np.ndarray:
    """ CT transition function"""
    if abs(x[4]) > 0.0001:
        xout = x
        theta = T * x[4]
        st = np.sin(theta)
        ct = np.cos(theta)
        xout[0] += st * x[2] / x[4] - (1 - ct) * x[3] / x[4]
        xout[1] += (1 - ct) * x[2] / x[4] + st * x[3] / x[4]
        xout[2:4] = rotmat2d(cos=ct, sin=st) @ xout[2:4]
    else:
        xout = x
        xout[:2] = T * xout[2:4]
    return xout


def sample_CT_trajectory(
        n: int,
        Ts: float,
        xbar0: ndarray,
        P0: ndarray,
        sigma_a: float,
        sigma_omega: float,
        sigma_z: float,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Sample a state trajectory X with measurements Z for n time steps of size Ts.

    The initial state is sampled from a Gaussian with mean xbar0 and covariance P0. The state
    trasitions follows that of the CV model where the linear acceleration covariance is specified by
    sigma_a and the rotational acceleration has covariance sigma_omegaq. The measurements are
    generated by sampling a Gaussian with mean x[:2] and covarance sigma_z * eye(2).
    """
    xbar = np.asfarray(xbar0)
    P = np.asfarray(P0)
    assert xbar.shape[0] == P.shape[0]
    assert xbar.shape[0] == P.shape[1]

    # some limits
    maxSpeed = 20
    maxTurn = np.pi/4

    # sqrt(covs)
    cholR = sigma_z * np.eye(2)

    Q = np.zeros((5, 5))
    Q[:4, :4] = sigma_a ** 2 * np.array(
        [[Ts**3 / 3,    0,          Ts**2 / 2,	0],
         [0,            Ts**3 / 3,  0,    	    Ts**2 / 2],
         [Ts**2 / 2,    0,          Ts,   	    0],
         [0,            Ts**2 / 2,  0,          Ts]]
    )
    Q[4, 4] = sigma_omega**2 * Ts
    cholQ = np.linalg.cholesky(Q)

    # allocate
    Z = np.zeros((n, 2))
    X = np.zeros((n, 5))

    # initialize
    X[0] = xbar0 \
        + np.linalg.cholesky(P0) @ np.random.normal(size=5)

    for k in range(n):
        # limit speed
        maxSpeedRatio = np.linalg.norm(X[k, 2:4]) / maxSpeed
        if maxSpeedRatio > 1:
            X[k, 2:4] /= np.sqrt(maxSpeedRatio)

        # limit turn rate
        if abs(X[k, 4]) > maxTurn:
            X[k, 4] = maxTurn * np.sign(X[k, 4])

        # measurement
        Z[k] = X[k, :2] + cholR @ np.random.normal(size=2)

        # predict
        if k < n-1:
            X[k+1] = f_m2_withT(X[k], Ts) + cholQ @ np.random.normal(size=5)

    return X, Z
